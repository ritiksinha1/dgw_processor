#! /usr/local/bin/python3
"""
    This module is responsible for generating lists of active academic plans and their subplans.
    Plans and subplans are known and connected to each other by the CUNY ACAD_PLAN_TBL and
    ACAD_SUBPLAN_TBL tables. The matching dap_req_block for each plan can be determined directly
    because the plan name in ACAD_PLAN_TBL will match the block_value attribute of the
    dap_req_block. Finding the matching dap_req_block for a subplan is less straightforward, and
    there will be cases where the correct choice among alternative possibilities can't be
    determined. All anomalies are logged.

    Once a dap_req_block for a plan or subplan has been identified, it is checked against the
    ir_active_blocks list generated by OAREDA to determine those blocks that will actually be made
    available to the course mapper for processing.

    During the mapping process, "OTHER" blocks may be called for, those have to be checked against
    ir_active_blocks as they are encountered.
"""

import psycopg
import sys

from argparse import ArgumentParser
from collections import namedtuple, defaultdict
from getch import getch, getche
from psycopg.rows import namedtuple_row
from quarantine_manager import QuarantineManager

quarantined_dict = QuarantineManager()

error_file = open('error.txt', 'w')
inactive_file = open('inactive.txt', 'w')
log_file = open('log.txt', 'w')
missing_file = open('missing.txt', 'w')


# RHS for plan and subplan dicts
PlanInfo = namedtuple('PlanInfo', 'plan, type description effective_date cip_code')
SubplanInfo = namedtuple('PlanInfo', 'subplan, type description effective_date cip_code')

active_blocks = dict()


with psycopg.connect('dbname=cuny_curriculum') as conn:
  with conn.cursor(row_factory=namedtuple_row) as cursor:

    # Create dict of "current terms" from cuny_sessions
    """ The CUNY session table has all the key dates for each session, both in the past and in the
        future. We take as "current" the semester that started most recently.
        Not all colleges follow the same academic calendar, so the current term has to be recorded
        separately for each college.
    """
    cursor.execute("""
    -- The first row for each college will be its current term
    select distinct on (institution)
           institution, term,
           (session_beginning_date::date - current_date) as diff
      from cuny_sessions
     where (session_beginning_date::date - current_date) <= 0 and session = '1'
       and institution !~* 'mhc' and institution !~* 'uapc' -- "Noise institutions"
     order by institution, diff desc
    """)
    current_terms = {row.institution: int(row.term) for row in cursor.fetchall()}

    # Create dict of requirement blocks that have been active “recently,” and their enrollments.
    # In T-Rex, ”recently offered” means within the past calendar year.
    cursor.execute('select * from active_req_blocks;')
    for row in cursor:
      current_term = current_terms[row.institution]
      first_recent_term = current_term - 10
      recent_enrollment = 0
      min_active_term = 99999
      max_active_term = 0
      num_recent_active_terms = 0
      for term_info in row.term_info:
        active_term = term_info['active_term']
        if active_term < min_active_term:
          min_active_term = active_term
        if active_term > max_active_term:
          max_active_term = active_term
        if active_term >= first_recent_term:
          # If available, include "next semester" in the count of active terms
          num_recent_active_terms += 1
          if active_term <= current_term:
            # But count only students in this semester or earlier
            # (If looking during add/drop period, count students who haven't added or dropped yet.)
            recent_enrollment += term_info['distinct_students']
      if num_recent_active_terms == 0:
        print(f'{row.institution} {row.requirement_id} Inactive since {first_recent_term}',
              file=inactive_file)
        continue

      row_dict = row._asdict()
      del row_dict['term_info']
      row_dict['first_active_term'] = min_active_term
      row_dict['last_active_term'] = max_active_term
      row_dict['num_recent_active_terms'] = num_recent_active_terms
      row_dict['recent_enrollment'] = recent_enrollment
      active_blocks[(row.institution, row.requirement_id)] = row_dict

    # Dict of all plans
    cursor.execute("""
    select institution, plan, plan_type, description, effective_date, cip_code
      from cuny_acad_plan_tbl
    """)
    all_acad_plans = {(row.institution, row.plan):
                      PlanInfo._make([row.plan,
                                      row.plan_type,
                                      row.description,
                                      str(row.effective_date),
                                      row.cip_code])
                      for row in cursor.fetchall()}

    # Dict of all subplans
    cursor.execute("""
    select institution, plan, subplan, subplan_type, description, effective_date, cip_code
      from cuny_acad_subplan_tbl
    """)
    all_acad_subplans = {(row.institution, row.plan, row.subplan):
                         SubplanInfo._make([row.subplan,
                                            row.subplan_type,
                                            row.description,
                                            str(row.effective_date),
                                            row.cip_code])._asdict()
                         for row in cursor.fetchall()}


def active_plans():
  """ Get Plans of interest and their associated subplans
  """
  with psycopg.connect('dbname=cuny_curriculum') as conn:
    with conn.cursor(row_factory=namedtuple_row) as cursor:
      cursor.execute(r"""
      select p.institution, p.plan, p.plan_type, coalesce(string_agg(s.subplan,':'), '') as subplans
        from cuny_acad_plan_tbl p
             left join cuny_acad_subplan_tbl s
                    on p.institution = s.institution
                   and p.plan = s.plan
      where p.plan !~* '^(mhc|cbuis)' -- Skip Honors College and CUNY BA/BS
        and (p.plan ~* '\-[AB]' or p.plan_type = 'MIN') -- Bachelor's/Associates' degree, or Minor
        and p.description !~* '^Unde' -- Skip “Undeclared” majors and minors
      group by p.institution, p.plan
      order by p.institution, p.plan
      """)

      # Build plan_dicts for active plans
      for row in cursor.fetchall():

        # Populate the plan_dict for this row.
        try:
          plan_dict = all_acad_plans[(row.institution, row.plan)]._asdict()
        except KeyError:
          print(f'{row.institution} {row.plan:>10} No active plan', file=missing_file)
          continue

        # Extract the string_agg of subplan names into a list of names, and initialize
        # plan_dict['subplans'] as a list of active subplan blocks
        subplans_list = row.subplans.split(':')
        plan_dict['subplans'] = []

        # Find current dap_req_block(s) for this plan. Hopefully, exactly one will be active
        with conn.cursor(row_factory=namedtuple_row) as req_block_cursor:
          req_block_cursor.execute("""
          select institution, requirement_id
            from requirement_blocks
           where institution = %s
             and block_value = %s
             and period_stop ~* '^9'
          """, (row.institution, row.plan))

          # Collect the active blocks; ignore others
          active_block_list = []
          for block_row in req_block_cursor.fetchall():
            try:
              active_block_list.append(active_blocks[(block_row.institution,
                                                      block_row.requirement_id)])
            except KeyError:
              # Scribe error: a "current" block is not "active"
              print(f'{row.institution} {block_row.requirement_id:>10} Current dap_req_block is '
                    f'not active', file=error_file)
              continue

          match len(active_block_list):
            case 0:
              print(f'{row.institution} {row.plan:>10} No active dap_req_block', file=missing_file)
              continue

            case 1:
              # Hoped-for case
              plan_dict['requirement_block'] = active_block_list[0]

              # Find all active dap_req_block(s) for its subplans, if any
              for subplan_name in subplans_list:
                if subplan_name == '':
                  # artifact of coalescing string_agg
                  continue

                # Start with all current concentration blocks that match this subplan name
                req_block_cursor.execute("""
                select institution, requirement_id
                  from requirement_blocks
                 where institution = %s
                   and block_type = 'CONC'
                   and block_value = %s
                   and period_stop ~* '^9'
                """, (row.institution, subplan_name))

                if req_block_cursor.rowcount == 0:
                  print(f'{row.institution} {row.plan:>10} No current dap_req_block '
                        f'for concentration {subplan_name}',
                        file=missing_file)
                  continue

                # Find active subplan blocks
                active_subplan_list = []
                for block_row in req_block_cursor.fetchall():
                  try:
                    active_subplan_list.append(active_blocks[(block_row.institution,
                                                              block_row.requirement_id)])
                  except KeyError:
                    # Scribe error: a "current" block is not "active" (ignore the block)
                    print(f'{block_row.institution} {row.plan:>10} Current block is not active',
                          file=error_file)

                # The dict to which the single matching requirement_block will be added, if found
                subplan_dict = all_acad_subplans[(row.institution, row.plan, subplan_name)]

                # If there is a single active block for the subplan, add it to the plan_dict
                # subplans list

                match len(active_subplan_list):
                  case 0:
                    # No active blocks for this subplan.
                    print(f'{row.institution} {row.plan:>10} No active dap_req_block for '
                          f'concentration {subplan_name}', file=missing_file)

                  case 1:
                    subplan_dict['requirement_block'] = active_subplan_list[0]
                    plan_dict['subplans'].append(subplan_dict)

                  case _:
                    # Multiple active blocks for this subplan.
                    # Don't give up yet: if the major1 field matches the plan exactly once, it's a
                    # match.
                    major1_match_list = []
                    for index, subplan_block in enumerate(active_subplan_list):
                      if subplan_block['major1'] == plan_dict['plan']:
                        major1_match_list.append(subplan_block)
                    match len(major1_match_list):
                      case 0:
                        print(f'{row.institution} {row.plan:>10} Multiple active dap_req_blocks '
                              f'for concentration {subplan_name} but no major1 matches',
                              file=missing_file)

                      case 1:
                        subplan_dict['requirement_block'] = major1_match_list[0]
                        plan_dict['subplans'].append(subplan_dict)

                      case _:
                        for index, subplan_block in enumerate(major1_match_list):
                          print(f'{row.institution} {row.plan:>10} Multiple active dap_req_blocks '
                                f'for concentration {subplan_name} with multiple major1 matches '
                                f'{index+1}/{len(major1_match_list)}: {subplan_block}',
                                file=error_file)

            case _:
              for index, active_block in enumerate(active_block_list):
                print(f'{active_block["institution"]} {active_block["requirement_id"]:>10} '
                      f'Multiple active dap_req_blocks for '
                      f'{row.plan} {index+1}/{len(active_block_list)}: '
                      f'{active_block["block_type"]} {active_block["block_value"]} '
                      f'{active_block["block_title"]}',
                      file=error_file)
              continue
        yield plan_dict


if __name__ == '__main__':
  """ Interactively ("more") display plan dicts. Institution and/or requirement_id filters are
      optional.
  """
  parser = ArgumentParser()
  parser.add_argument('-i', '--institution', default=None)
  parser.add_argument('-r', '--requirement_id', default=None)
  args = parser.parse_args()

  if args.institution:
    institution = args.institution.upper()[0:3] + '01'
  else:
    institution = None

  if args.requirement_id:
    requirement_id = f'RA{int(args.requirement_id.strip("RA")):06}'
  else:
    requirement_id = None

  for plan in active_plans():
    if institution and plan['requirement_block']['institution'] != institution:
      continue
    if requirement_id:
      # the block might be the plan block or one of the subplans' blocks
      requirement_blocks = [subplan['requirement_block']['requirement_id']
                            for subplan in plan['subplans']]
      requirement_blocks.append(plan['requirement_block']['requirement_id'])
      if requirement_id not in requirement_blocks:
        continue
    print(plan)
    print('more? ', end='')
    sys.stdout.flush()
    ch = getch().lower()
    # Blank line after each dict
    print('\r     ')
    # Esc or q to exit
    if ch == 'q' or ch == '\u001b':
      exit()
