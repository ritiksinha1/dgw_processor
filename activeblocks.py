#! /usr/local/bin/python3
"""
    This module is responsible for generating lists of active academic plans and their subplans.
    Plans and subplans are known and connected to each other by the CUNY ACAD_PLAN_TBL and
    ACAD_SUBPLAN_TBL tables. The matching dap_req_block for each plan can be determined directly
    because the plan name in ACAD_PLAN_TBL will match the block_value attribute of the
    dap_req_block. Finding the matching dap_req_block for a subplan is less straightforward, and
    there will be cases where the correct choice among alternative possibilities can't be
    determined. All anomalies are logged.

    Once a dap_req_block for a plan or subplan has been identified, it is checked against the
    ir_active_blocks list generated by OAREDA to determine those blocks that will actually be made
    available to the course mapper for processing.

    During the mapping process, "OTHER" blocks may be called for, those have to be checked against
    ir_active_blocks as they are encountered.
"""

import psycopg
import sys

from argparse import ArgumentParser
from collections import namedtuple, defaultdict
from psycopg.rows import namedtuple_row

error_file = open('error.txt', 'w')
inactive_file = open('inactive.txt', 'w')
log_file = open('log.txt', 'w')
missing_file = open('missing.txt', 'w')


# Same rhs for plan and subplan dicts
PlanInfo = namedtuple('PlanInfo', 'type description effective_date cip_code')

active_blocks = dict()


with psycopg.connect('dbname=cuny_curriculum') as conn:
  with conn.cursor(row_factory=namedtuple_row) as cursor:

    # Create dict of "current terms" from cuny_sessions
    cursor.execute("""
    -- The last row for each college will be its current term
    select institution, term, census_date::date, (census_date::date - current_date) as diff
      from cuny_sessions
     where census_date::date - current_date > 0 and session = '1'
     order by institution, diff desc
    """)
    # The table has a history of active terms: the term value will be updated until the
    # last row for that college is reached
    current_terms = {row.institution: int(row.term) for row in cursor.fetchall()}

    # Create dict of currently-active requirement blocks.
    cursor.execute("""
    select *
      from active_req_blocks
    ;
    """)
    for row in cursor:
      latest_term = row.term_info[-1]
      if latest_term['active_term'] < current_terms[row.institution]:
        print(f'{row.institution} {row.requirement_id} Not currently active', file=inactive_file)
        continue
      row_dict = row._asdict()
      del row_dict['term_info']
      row_dict['active_term'] = latest_term['active_term']
      row_dict['enrollment'] = latest_term['distinct_students']
      active_blocks[(row.institution, row.requirement_id)] = row_dict

    # Dict of all plans
    cursor.execute("""
    select institution, plan, plan_type, description, effective_date, cip_code
      from cuny_acad_plan_tbl
    """)
    all_acad_plans = {(row.institution, row.plan):
                      PlanInfo._make([row.plan_type,
                                      row.description,
                                      str(row.effective_date),
                                      row.cip_code])
                      for row in cursor.fetchall()}

    # Dict of all subplans
    cursor.execute("""
    select institution, plan, subplan, subplan_type, description, effective_date, cip_code
      from cuny_acad_subplan_tbl
    """)
    acad_subplans = {(row.institution, row.plan, row.subplan):
                     PlanInfo._make([row.subplan_type,
                                     row.description,
                                     str(row.effective_date),
                                     row.cip_code])
                     for row in cursor.fetchall()}


def acad_plans():
  """ Get Plans of interest and their associated subplans
  """
  with psycopg.connect('dbname=cuny_curriculum') as conn:
    with conn.cursor(row_factory=namedtuple_row) as cursor:
      cursor.execute(r"""
      select p.institution, p.plan, coalesce(string_agg(s.subplan,':'), '') as subplans
        from cuny_acad_plan_tbl p
             left join cuny_acad_subplan_tbl s
                    on p.institution = s.institution
                   and p.plan = s.plan
      where p.plan !~* '^(mhc|cbuis)' -- Skip Honors College and CUNY BA/BS
        and p.plan ~* '\-[AB]' -- Must lead to bachelor or associate degree
        and p.description !~* '^Unde' -- Skip “Undeclared” majors and minors
      group by p.institution, p.plan
      order by p.institution, p.plan
      """)

      print(f'{cursor.rowcount:5,} potential academic plans', file=log_file)

      # Build plan_dicts for active plans
      for row in cursor.fetchall():

        # Populate the plan_dict for this row.
        try:
          plan_dict = all_acad_plans[(row.institution, row.plan)]._asdict()
        except KeyError:
          print(f'{row.institution} {row.plan:>10} No active plan', file=missing_file)
          continue

        # Extract the string_agg of subplan names into a list of names, and initialize
        # plan_dict['subplans'] as a list of active subplan blocks
        subplans_list = row.subplans.split(':')
        plan_dict['subplans'] = []

        # Find current dap_req_block(s) for this plan. Hopefully, exactly one will be active
        with conn.cursor(row_factory=namedtuple_row) as req_block_cursor:
          req_block_cursor.execute("""
          select institution, requirement_id
            from requirement_blocks
           where institution = %s
             and block_value = %s
             and period_stop ~* '^9'
          """, (row.institution, row.plan))

          # Collect the active blocks; ignore others
          active_block_list = []
          for block_row in req_block_cursor.fetchall():
            try:
              active_block_list.append(active_blocks[(block_row.institution,
                                                      block_row.requirement_id)])
            except KeyError:
              # Scribe error: a "current" block is not "active"
              print(f'{row.institution} {block_row.requirement_id:>10} Current dap_req_block is not '
                    f'active', file=error_file)
              continue

          match len(active_block_list):
            case 0:
              print(f'{row.institution} {row.plan:>10} No active dap_req_block', file=missing_file)
              continue

            case 1:
              # Hoped-for case
              plan_dict['requirement_block'] = active_block_list[0]

              # Find all active dap_req_block(s) for its subplans, if any
              for subplan_name in subplans_list:
                if subplan_name == '':
                  # artifact of coalescing string_agg
                  continue

                # Start with all current concentration blocks that match this subplan name
                req_block_cursor.execute("""
                select institution, requirement_id
                  from requirement_blocks
                 where institution = %s
                   and block_type = 'CONC'
                   and block_value = %s
                   and period_stop ~* '^9'
                """, (row.institution, subplan_name))

                if req_block_cursor.rowcount == 0:
                  print(f'{row.institution} {row.plan:>10} No current dap_req_block '
                        f'for concentration {subplan_name}',
                        file=missing_file)
                  continue

                # Find active subplan blocks
                active_subplan_list = []
                for block_row in req_block_cursor.fetchall():
                  try:
                    active_subplan_list.append(active_blocks[(block_row.institution,
                                                              block_row.requirement_id)])
                  except KeyError:
                    # Scribe error: a "current" block is not "active" (ignore the block)
                    print(f'{block_row.institution} {row.plan:>10} Current block is not active',
                          file=error_file)

                # If there is a single active block for the subplan, add it to the plan_dict subplans
                # list
                match len(active_subplan_list):
                  case 0:
                    # No active blocks for this subplan.
                    print(f'{row.institution} {row.plan:>10} No active dap_req_block for '
                          f'concentration {subplan_name}', file=missing_file)

                  case 1:
                    plan_dict['subplans'].append(active_subplan_list[0])

                  case _:
                    # Multiple active blocks for this subplan.
                    # Don't give up yet: if the major1 field matches the plan exactly once, it's a
                    # match.
                    major1_match_list = []
                    for index, subplan_block in enumerate(active_subplan_list):
                      if subplan_block.major1 == plan_dict['plan']:
                        major1_match_list.append(subplan_block)
                    match len(major1_match_list):
                      case 0:
                        print(f'{row.institution} {row.plan:>10} Multiple active dap_req_blocks for '
                              f'concentration {subplan_name} but no major1 matches',
                              file=missing_file)

                      case 1:
                        plan_dict['subplans'].append(major1_match_list[0])

                      case _:
                        for index, subplan_block in enumerate(major1_match_list):
                          print(f'{row.institution} {row.plan:>10} Multiple active dap_req_blocks '
                                f'for concentration {subplan_name} with multiple major1 matches '
                                f'{index+1}/{len(major1_match_list)}: {subplan_block}',
                                file=error_file)

            case _:
              for index, active_block in enumerate(active_block_list):
                print(f'{active_block["institution"]} {active_block["requirement_id"]:>10} Multiple '
                      f'active dap_req_blocks for {row.plan} {index+1}/{len(active_block_list)}: '
                      f'{active_block["block_type"]} {active_block["block_value"]} '
                      f'{active_block["block_title"]}',
                      file=error_file)
              continue
        yield plan_dict


if __name__ == '__main__':
  """ Print "more" plan dicts
  """
  parser = ArgumentParser()
  parser.add_argument('-i', '--institution', default=None)
  parser.add_argument('-r', '--requirement_id', default=None)
  args = parser.parse_args()

  if args.institution:
    institution = args.institution.upper()[0:3] + '01'
  else:
    institution = None

  if args.requirement_id:
    requirement_id = f'RA{int(args.requirement_id.strip("RA")):06}'
  else:
    requirement_id = None

  for plan in acad_plans():
    if institution and plan['requirement_block']['institution'] != institution:
      continue
    if requirement_id:
      # the block might be the plan block or one of the subplan's block
      requirement_blocks = [subplan['requirement_id'] for subplan in plan['subplans']]
      requirement_blocks.append(plan['requirement_block']['requirement_id'])
      if requirement_id not in requirement_blocks:
        continue
    print(plan)
    print('more? ', end='')
    try:
      reply = input()
      if reply.lower().startswith('q'):
        raise EOFError
    except EOFError:
      exit()
